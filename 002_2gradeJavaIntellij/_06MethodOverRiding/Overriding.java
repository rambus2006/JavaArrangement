package _06MethodOverRiding;
/*게임에서 무기를 표현하는 Weapon클래스를 만들고 살상 능력을 리턴하는 fire()메소드는 다음과
* 같다. fire()은 1을 리턴한다. (뭐 이런 무서운 코드가 다있냐 */
class Weapon {
    protected int fire(){
        return 1; //무기는 기본적으로 한명만 살상
    }
}
class Cannon extends Weapon{
    @Override
    protected int fire(){ //오버라이딩
        return 10; //대포는 한 번에 10명을 살상
    }
}
/*대포를 구현하기 위해 Weapon을 상속받는 Cannon 클래스를 작성하라.Cannon은 살상능력이 10이다.
fire()메소드를 이에 맞게 오버라이딩하라. main()을 작성하여 오버라이딩을 테스트 하라.
* */
public class Overriding {
    public static void main(String[] args) {
        Weapon weapon;
        weapon=new Weapon();
        System.out.println("기본 무기의 살상 능력은 "+weapon.fire());
        weapon =new Cannon();
        System.out.println("대포의 살상 능력은 "+ weapon.fire());
    }
}
/*
{ 오버라이딩 }
- 같은 이름의 메소드를 중복하여 정의하는 것=> 객체 지향의 다형성 실현
- 기본적으로 한 클래스 내에 같은 이름의 메소드를 둘 이상 가질 수 없지만, 매개변수의 개수나 타입 혹은
순서를 다르게 하면 같은 이름의 메소드를 여러개 작성할 수 있다.
-동적 바인딩이 발생한다. (서브 클래스에 오버라이딩된 메소드가 무조건 실행된다.)

오버라이딩과 오버로딩의 차이
<메소드 오버라이딩>
-선언 : 서브 클래스에서 슈퍼클래스에 있는 메소드와 동일한 이름의 메소드 재작성
-관계 : 상속관계
-목적 : 슈퍼 클래스에 구현된 메소드를 무시하고 서브 클래스에서 새로운 기능의 메소드를 재정의하고자 함=>다형성 실현
-조건 : 메소드의 이름, 매개변수 타입과 개수, 리턴 타입이 모두 동일하여야 성립
-바인딩 : 동적 바인딩, 실행 시간에 오버라이딩 된 메소드를 찾아 호출

<메소드 오버로딩>
-선언 : 같은 클래스나 상속관계에서 동일한 이름의 메소드 중복 작성
-관계 : 동일한 클래스 내 혹은 상속 관계
-목적 : 이름이 같은 여러 개의 메소드를 중복 작성하여 사용의 편리성 향상=>다형성 실현
-조건 : 메소드 이름은 반드시 동일하고, 매개변수 타입이나 개수가 달라야 성립
-바인딩 : 정적 바인딩, 호출될 메소드는 컴파일 시에 결정
*/
